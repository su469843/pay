require('dotenv').config({ path: '.env.local' });
const { Client } = require('pg');
const tls = require('tls');
const https = require('https');

console.log('üîß Windows TLS ‰øÆÂ§çÂ∑•ÂÖ∑');
console.log('======================\n');

const host = process.env.PGHOST;
const port = 5432;
const database = process.env.PGDATABASE;
const user = process.env.PGUSER;
const password = process.env.PGPASSWORD;

// 1. ÊµãËØï‰∏çÂêåÁöÑ TLS ÁâàÊú¨
async function testTLSVersions() {
  console.log('üîÑ ÊµãËØï 1: ‰∏çÂêå TLS ÁâàÊú¨');
  
  const tlsVersions = [
    { name: 'TLSv1.3', version: 'TLSv1.3' },
    { name: 'TLSv1.2', version: 'TLSv1.2' },
    { name: 'TLSv1.1', version: 'TLSv1.1' },
    { name: 'TLSv1', version: 'TLSv1' }
  ];
  
  for (const { name, version } of tlsVersions) {
    console.log(`\n   ÊµãËØï ${name}...`);
    
    try {
      const client = new Client({
        host,
        port,
        database,
        user,
        password,
        ssl: {
          rejectUnauthorized: false,
          secureProtocol: version + '_method',
          checkServerIdentity: () => undefined
        },
        connectionTimeoutMillis: 10000
      });
      
      await client.connect();
      console.log(`   ‚úÖ ${name} ËøûÊé•ÊàêÂäü!`);
      
      const result = await client.query('SELECT NOW()');
      console.log(`   ‚úÖ Êü•ËØ¢ÊàêÂäü:`, result.rows[0]);
      
      await client.end();
      return { success: true, version: name };
    } catch (error) {
      console.log(`   ‚ùå ${name} Â§±Ë¥•:`, error.message);
    }
  }
  
  return { success: false };
}

// 2. ÊµãËØï‰∏çÂêåÁöÑÂØÜÁ†ÅÂ•ó‰ª∂
async function testCipherSuites() {
  console.log('\nüîÑ ÊµãËØï 2: ‰∏çÂêåÂØÜÁ†ÅÂ•ó‰ª∂');
  
  const cipherSuites = [
    {
      name: 'Áé∞‰ª£ÂØÜÁ†ÅÂ•ó‰ª∂',
      ciphers: 'ECDHE+AESGCM:ECDHE+CHACHA20:DHE+AESGCM:DHE+CHACHA20:!aNULL:!MD5:!DSS'
    },
    {
      name: 'ÂÖºÂÆπÂØÜÁ†ÅÂ•ó‰ª∂',
      ciphers: 'HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA'
    },
    {
      name: 'ÂÆΩÊùæÂØÜÁ†ÅÂ•ó‰ª∂',
      ciphers: 'ALL:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5'
    }
  ];
  
  for (const { name, ciphers } of cipherSuites) {
    console.log(`\n   ÊµãËØï ${name}...`);
    
    try {
      const client = new Client({
        host,
        port,
        database,
        user,
        password,
        ssl: {
          rejectUnauthorized: false,
          ciphers: ciphers,
          checkServerIdentity: () => undefined
        },
        connectionTimeoutMillis: 10000
      });
      
      await client.connect();
      console.log(`   ‚úÖ ${name} ËøûÊé•ÊàêÂäü!`);
      
      await client.end();
      return { success: true, ciphers: name };
    } catch (error) {
      console.log(`   ‚ùå ${name} Â§±Ë¥•:`, error.message);
    }
  }
  
  return { success: false };
}

// 3. ÊµãËØï Windows ÁâπÂÆöÁöÑ TLS ËÆæÁΩÆ
async function testWindowsSpecific() {
  console.log('\nüîÑ ÊµãËØï 3: Windows ÁâπÂÆöËÆæÁΩÆ');
  
  const configs = [
    {
      name: 'Windows ÂÖºÂÆπÊ®°Âºè',
      ssl: {
        rejectUnauthorized: false,
        checkServerIdentity: () => undefined,
        secureOptions: require('constants').SSL_OP_LEGACY_SERVER_CONNECT
      }
    },
    {
      name: 'Á¶ÅÁî® SNI',
      ssl: {
        rejectUnauthorized: false,
        checkServerIdentity: () => undefined,
        servername: undefined
      }
    },
    {
      name: 'Âº∫Âà∂ IPv4',
      ssl: {
        rejectUnauthorized: false,
        checkServerIdentity: () => undefined
      },
      family: 4
    },
    {
      name: 'ÊúÄÂ∞è TLS ËÆæÁΩÆ',
      ssl: {
        rejectUnauthorized: false,
        requestCert: false,
        agent: false
      }
    }
  ];
  
  for (const { name, ssl, ...otherOptions } of configs) {
    console.log(`\n   ÊµãËØï ${name}...`);
    
    try {
      const client = new Client({
        host,
        port,
        database,
        user,
        password,
        ssl,
        connectionTimeoutMillis: 10000,
        ...otherOptions
      });
      
      await client.connect();
      console.log(`   ‚úÖ ${name} ËøûÊé•ÊàêÂäü!`);
      
      await client.end();
      return { success: true, config: name };
    } catch (error) {
      console.log(`   ‚ùå ${name} Â§±Ë¥•:`, error.message);
    }
  }
  
  return { success: false };
}

// 4. ÊµãËØïÂéüÁîü TLS ËøûÊé•
async function testNativeTLS() {
  console.log('\nüîÑ ÊµãËØï 4: ÂéüÁîü TLS ËøûÊé•');
  
  return new Promise((resolve) => {
    const options = {
      host: host,
      port: port,
      rejectUnauthorized: false,
      timeout: 10000,
      checkServerIdentity: () => undefined
    };
    
    console.log('   Â∞ùËØïÂéüÁîü TLS ËøûÊé•...');
    
    const socket = tls.connect(options, () => {
      console.log('   ‚úÖ ÂéüÁîü TLS ËøûÊé•ÊàêÂäü!');
      console.log('   ÂçèËÆÆ:', socket.getProtocol());
      console.log('   ÂØÜÁ†ÅÂ•ó‰ª∂:', socket.getCipher()?.name || 'Unknown');
      
      // Â∞ùËØïÂèëÈÄÅ PostgreSQL ÂêØÂä®Ê∂àÊÅØ
      const startupMessage = Buffer.alloc(8);
      startupMessage.writeInt32BE(8, 0); // Ê∂àÊÅØÈïøÂ∫¶
      startupMessage.writeInt32BE(196608, 4); // ÂçèËÆÆÁâàÊú¨ 3.0
      
      socket.write(startupMessage);
      
      socket.on('data', (data) => {
        console.log('   ‚úÖ Êî∂Âà∞ÊúçÂä°Âô®ÂìçÂ∫î:', data.length, 'Â≠óËäÇ');
        socket.destroy();
        resolve({ success: true });
      });
      
      setTimeout(() => {
        console.log('   ‚ùå ÊúçÂä°Âô®ÂìçÂ∫îË∂ÖÊó∂');
        socket.destroy();
        resolve({ success: false });
      }, 5000);
    });
    
    socket.on('error', (error) => {
      console.log('   ‚ùå ÂéüÁîü TLS ËøûÊé•Â§±Ë¥•:', error.message);
      resolve({ success: false });
    });
    
    socket.on('timeout', () => {
      console.log('   ‚ùå ÂéüÁîü TLS ËøûÊé•Ë∂ÖÊó∂');
      socket.destroy();
      resolve({ success: false });
    });
  });
}

// 5. ÊµãËØï HTTPS ËøûÊé•Âà∞ Supabase API
async function testSupabaseAPI() {
  console.log('\nüîÑ ÊµãËØï 5: Supabase API ËøûÊé•');
  
  // ‰ªéÊï∞ÊçÆÂ∫ì‰∏ªÊú∫Êé®Êñ≠ API Á´ØÁÇπ
  const apiHost = host.replace('db.', 'api.');
  const apiUrl = `https://${apiHost}/rest/v1/`;
  
  console.log(`   ÊµãËØï API Á´ØÁÇπ: ${apiUrl}`);
  
  return new Promise((resolve) => {
    const req = https.get(apiUrl, {
      timeout: 10000,
      rejectUnauthorized: false
    }, (res) => {
      console.log('   ‚úÖ HTTPS API ËøûÊé•ÊàêÂäü!');
      console.log('   Áä∂ÊÄÅÁ†Å:', res.statusCode);
      console.log('   TLS ÁâàÊú¨:', res.socket?.getProtocol?.());
      resolve({ success: true });
    });
    
    req.on('error', (error) => {
      console.log('   ‚ùå HTTPS API ËøûÊé•Â§±Ë¥•:', error.message);
      resolve({ success: false });
    });
    
    req.on('timeout', () => {
      console.log('   ‚ùå HTTPS API ËøûÊé•Ë∂ÖÊó∂');
      req.destroy();
      resolve({ success: false });
    });
  });
}

// 6. ÁîüÊàê‰øÆÂ§çÂª∫ËÆÆ
function generateFixSuggestions(results) {
  console.log('\nüí° ‰øÆÂ§çÂª∫ËÆÆ:');
  console.log('============');
  
  if (results.tlsVersions.success) {
    console.log(`‚úÖ ‰ΩøÁî® ${results.tlsVersions.version} ÂèØ‰ª•ËøûÊé•`);
    console.log('   Âª∫ËÆÆÂú®Â∫îÁî®‰∏≠Âõ∫ÂÆö‰ΩøÁî®Ê≠§ TLS ÁâàÊú¨');
  }
  
  if (results.cipherSuites.success) {
    console.log(`‚úÖ ‰ΩøÁî® ${results.cipherSuites.ciphers} ÂèØ‰ª•ËøûÊé•`);
    console.log('   Âª∫ËÆÆÂú®Â∫îÁî®‰∏≠‰ΩøÁî®Ê≠§ÂØÜÁ†ÅÂ•ó‰ª∂ÈÖçÁΩÆ');
  }
  
  if (results.windowsSpecific.success) {
    console.log(`‚úÖ ‰ΩøÁî® ${results.windowsSpecific.config} ÂèØ‰ª•ËøûÊé•`);
    console.log('   Âª∫ËÆÆÂú®Â∫îÁî®‰∏≠‰ΩøÁî®Ê≠§ Windows ÁâπÂÆöÈÖçÁΩÆ');
  }
  
  if (!results.tlsVersions.success && !results.cipherSuites.success && !results.windowsSpecific.success) {
    console.log('‚ùå ÊâÄÊúâ TLS ÈÖçÁΩÆÈÉΩÂ§±Ë¥•‰∫Ü');
    console.log('\nÂèØËÉΩÁöÑËß£ÂÜ≥ÊñπÊ°à:');
    console.log('1. Êõ¥Êñ∞ Windows Á≥ªÁªüÂíåËØÅ‰π¶');
    console.log('2. Ê£ÄÊü•‰ºÅ‰∏öÈò≤ÁÅ´Â¢ôÊàñ‰ª£ÁêÜËÆæÁΩÆ');
    console.log('3. Â∞ùËØï‰ΩøÁî® VPN Êàñ‰∏çÂêåÁöÑÁΩëÁªú');
    console.log('4. ËÅîÁ≥ªÁ≥ªÁªüÁÆ°ÁêÜÂëòÊ£ÄÊü• TLS Á≠ñÁï•');
    console.log('5. ËÄÉËôë‰ΩøÁî® Supabase ÁöÑËøûÊé•Ê±†Êàñ API Êõø‰ª£Áõ¥Ëøû');
  }
  
  if (results.supabaseAPI.success && !results.nativeTLS.success) {
    console.log('\nüîç ÁâπÊÆäÊÉÖÂÜµ: HTTPS API ÂèØÁî®‰ΩÜÊï∞ÊçÆÂ∫ì TLS ‰∏çÂèØÁî®');
    console.log('   Âª∫ËÆÆ: ËÄÉËôë‰ΩøÁî® Supabase ÁöÑ REST API Êàñ GraphQL API');
    console.log('   ËÄå‰∏çÊòØÁõ¥Êé•ÁöÑ PostgreSQL ËøûÊé•');
  }
}

// ‰∏ªÂáΩÊï∞
async function runTLSFix() {
  console.log('üöÄ ÂºÄÂßã Windows TLS ‰øÆÂ§ç...\n');
  
  const results = {
    tlsVersions: await testTLSVersions(),
    cipherSuites: await testCipherSuites(),
    windowsSpecific: await testWindowsSpecific(),
    nativeTLS: await testNativeTLS(),
    supabaseAPI: await testSupabaseAPI()
  };
  
  console.log('\nüìä ÊµãËØïÁªìÊûúÊ±áÊÄª:');
  console.log('==================');
  Object.entries(results).forEach(([test, result]) => {
    const status = result.success ? '‚úÖ ÊàêÂäü' : '‚ùå Â§±Ë¥•';
    const detail = result.version || result.ciphers || result.config || '';
    console.log(`${test}: ${status} ${detail}`);
  });
  
  generateFixSuggestions(results);
  
  // Â¶ÇÊûúÊâæÂà∞ÂèØÁî®ÁöÑÈÖçÁΩÆÔºåÁîüÊàêÁ§∫‰æã‰ª£Á†Å
  const workingConfigs = Object.entries(results)
    .filter(([_, result]) => result.success)
    .map(([test, result]) => ({ test, ...result }));
  
  if (workingConfigs.length > 0) {
    console.log('\nüìù ÂèØÁî®ÁöÑÈÖçÁΩÆÁ§∫‰æã:');
    console.log('==================');
    
    workingConfigs.forEach(config => {
      console.log(`\n// ${config.test} ÈÖçÁΩÆ`);
      console.log('const client = new Client({');
      console.log('  host: process.env.PGHOST,');
      console.log('  port: 5432,');
      console.log('  database: process.env.PGDATABASE,');
      console.log('  user: process.env.PGUSER,');
      console.log('  password: process.env.PGPASSWORD,');
      
      if (config.version) {
        console.log('  ssl: {');
        console.log('    rejectUnauthorized: false,');
        console.log(`    secureProtocol: '${config.version}_method',`);
        console.log('    checkServerIdentity: () => undefined');
        console.log('  },');
      } else if (config.ciphers) {
        console.log('  ssl: {');
        console.log('    rejectUnauthorized: false,');
        console.log(`    ciphers: '${config.ciphers}',`);
        console.log('    checkServerIdentity: () => undefined');
        console.log('  },');
      }
      
      console.log('  connectionTimeoutMillis: 10000');
      console.log('});');
    });
  }
}

runTLSFix().catch(console.error);